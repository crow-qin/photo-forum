w3:{
	======d5----12.27======
	uniapp限制input字符长度
		maxlength="n"
	
	uniapp 点击按钮后聚焦到input
		设置一个标志量 x:true
		<input :focus="x" />
		当x的值为true时，input就会聚焦
	
	uniapp 长按事件 longpress
	
	flex小知识
		display: flex flex布局
		justify-content: space-between 位于首尾两端的子容器两端对齐
		flex-basis: 172rpx 子容器基准大小 表示在不伸缩的情况下子容器的原始尺寸
		flex-shrink: 0 收缩比例
		white-space: nowrap 规定段落中的文本不进行换行
		overflow-x: auto 横向溢出元素的内容区域添加滚动
	
	es6 
	键名为变量时 应该用 [] 括起来
	
	
	======d6----12.28======
	
	uniapp switch会向上冒泡
	
		解决 在switch中加入catch:tap='空函数'
}

w5: {
  =====d2----1.07=====
  
  canvas设置背景图
  用css或内联样式设置background: '图片路径'

  moment.js 日期格式类型转换类库

  qs对象序列化工具
    将对象序列化 对象的键值对用&拼接
    qs.stringify()

    将序列化的内容拆分
    qs.parse()

    post
    增加

    put
    修改

    delete
    删除
    
    `transformRequest` 允许在向服务器发送前，修改请求数据
    // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法
    
}

w6: {
  =====d3----1.15=====
	uniapp可以直接修改data中的对象数据
	
	横向滑动导航栏
	
	获取当前窗口的宽度
	let clientWidth = document.documentElement.clientWidth
	
	当前点击元素的宽度
	itemWidth = e.target.offsetWidth
	
	当前点击元素移动的距离
	move = e.target.offsetLeft
	
	目标居中的距离
	let left = move - (clientWidth / 2) + (itemWidth / 2)
	
	父盒子.scrollLeft =  left
	
	
  =====d5----1.17=====	
  
  canvas中心旋转

    let canvas = document.getElmentById('canvas')

    ctx = canvas.getContext('2d')

    // 先坐标偏移到画布中心
    ctx.translate(halfx,halfy)

    // 进行旋转 deg为度数 旋转为顺时针
    ctx.rotate(deg/180*Math.PI)

    // 如果接下来的操作仍以左上角为坐标轴,画布需要再次移动回去
    ctx.translate(-halfx,-halfy)

  全局前置守卫

    beforeEach(ansyc (to,from, next)=>{
      // to: Route: 即将进入的路由
      // from: Route: 正在离开的路由
      // next: Function: 一定要next
    })

  解决beforEach无限循环
    beforeEach结尾必须执行next()
    路由跳转 属性必须一致 to.name next({name:''})/to.path next({path:'/'})
    beforeEach中存在异步调用函数 加上ansyc 函数调用加上await

  setInterval越来越快


  arguments
    arguments: Array: 函数的实参
    arguments.callee Function: 函数自身

    现在不推荐使用arguments 建议使用命名函数表达式

    funtion fn() {
      fn()
    }
	
  =====d6----1.18=====
  
  将画布状态存到一个栈中 
	ctx.save()
  恢复canvas之前保存的状态
	ctx.restore()
  
}

==2020===

w1: {
  =====d3----02-19=====
  mixins和extends都可以算作一种继承

  mixins 
  混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。
  当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。
  mixins 选项接受一个混合对象的数组。
  
  2.mixins用途
    1、在你已经写好了构造器后，需要增加方法或者临时的活动时使用的方法，这时用混入会减少源代码的污染。

    2、很多地方都会用到的公用方法，用混入的方法可以减少代码量，实现代码重用。
	
  3.mixins的调用顺序
    1.继承钩子函数
      全局混入(Vue.mixin) > 混入对象的钩子函数 > 组件自身钩子
    


  extends 扩展

  1.extends用法
    extends选项允许声明扩展另一个组件，而无需使用 Vue.extend。
    通过外部增加对象的形式，对构造器进行扩展。它和混入mixins非常的类似。
    只不过接收的参数是简单的选项对象或构造函数,所以extends只能单次扩展一个组件。

  2.执行的先后顺序，
  执行的先后顺序和mixins一样
  扩展的方法与原生的冲突时，扩展的方法不生效，这点跟混入一样

  3.extends和mixins优先级比较
  extends的优先级 >mixins的优先级


  extend
  Vue.extend只是创建一个构造器,它是为了创建可复用的组件。
  其主要用来服务于Vue.component，用来生成组件

   方式1：先创建组件构造器，然后由组件构造器创建组件
         
    1.使用Vue.extend()创建一个组件构造器
    var MyComponent = Vue.extend({
      template: '<h3>Hello World</h3>'
    })
}	

w2: {
  =====d7----4.26=====
  
	uniapp 跳转到电话拨号
	uni.makePhonecell({
		phoneNumber: ''
	})
	
	uniapp 跳转到其他小程序
	wx.navigateToMiniProgram({
		appId: '',
		path: '',
		envVersion: 'release',
		success: 
	})
	
	
}

w3: {
	=====d1----4.27=====
	微信小程序canvas不跟随滚动条滑动
	
		父布局中有一句
		display: flex;
	
	微信登录
	<button open-type="get">
	uni.login
}

2020复工
w1: {
	=====d3----05.06=====
  rifeng
  图片路径无效
  获取验证码无效

  =====d5----05.08=====
  切换语言
  vue-i18n
  初始化 
  npm下载

  语言包自己写
  zh-cn.js
  en.js

  main.js引用
  import VueI18n from  'vue-i18n'
  import cn from 'xx'
  import en from 'xxx'
  Vue.use(VueI18n)

  const i18n = new VueI18n({
    // #ifdef MP-WEIXIN	
 	  locale: uni.getStorageSync('locale') || 'zh-CN', //初始化,保证刷新页面也保留
 	  // #endif
 	  // #ifdef APP-PLUS
    locale: plus.storage.getItem('locale') || 'zh-CN', //初始化,保证刷新页面也保留
    // #endif
    // #ifdef H5
    locale: localStorage.getItem('locale') || 'zh-CN', //初始化,保证刷新页面也保留
    // #endif
 
  	// 加载语言文件的内容
    messages: {
      'zh-CN': cn,
      'en': en
    })
    Vue.prototype._i18n = i18n  

    const app = new Vue({
      i18n,
        ...App,
        store  //挂载
    })

  切换语言方法
  // #ifdef WP-WEIXIN
  uni.setStorageSync('locale',item)
  // #endif
  // #ifdef APP-PLUS
  plus.storage.setItem('locale',item) 
  // #endif
  // #ifdef H5
  localStorage.setItem('locale',item)
  // #endif
  
  页面内的使用
  <view>{{$t('tabBar.home')}}</view>

  字符串，变量拼接
  具名格式
  const messages = {
    en: {
      message: {
        hello: '{msg} world'
      }
    }
  }

  <p>{{ $t('message.hello', { msg: 'hello' }) }}</p>
  <p>{{ $t('message.hello', { msg: msg }) }}</p>
  
  列表格式
  const messages = {
    en: {
      message: {
        hello: '{0} world'
      }
    }
  }
  <p>{{ $t('message.hello', { '0': 'hello' }) }}</p>
  
  微信小程序 
  修改底部导航栏和头部标题 
  放在onShow()中，或onload()中
  onShow() {
		// 修改底部导航
		uni.setTabBarItem({
			index: 0,
			text: this.$i18n.messages[this.$i18n.locale].tabBar.home
		});
	    // 修改头部标题
		uni.setNavigationBarTitle({
			title: this.$i18n.messages[this.$i18n.locale].tabBar.market
		});
  }
  
  =====d6----05.09=====
  
  websocket
    服务器端
    npm i ws
    代码
    // 导入WebSocket模块:
    const WebSocket = require('ws');

    // 引用Server类:
    const WebSocketServer = WebSocket.Server;

    // 实例化:
    const wss = new WebSocketServer({
        port: 3001
    });
    
    有WebSocket请求接入，wss对象可以响应connection事件来处理这个WebSocket：
    wss.on('connection', function (ws) {
      console.log('[SERVER] connection()');
      ws.on('message', function (message) {
        console.log('[SERVER] Received: ',${message});
        ws.send('ECHO:' + ${message}, (err) => {
          if (err) {
            console.log('[SERVER] error:', ${err});
          }
        });
      })
    })
    在connection事件中，回调函数会传入一个WebSocket的实例，
    message事件是当接收到客户端数据后的方法
    send用于向客户端发送数据
    
    客户端代码
    let ws = new WebSocket('ws://localhost:3001/test');

    // 打开WebSocket连接后立刻发送一条消息:
    ws.on('open', function () {
        console.log('[CLIENT] open()');
        ws.send('Hello!');
    });

    // 响应收到的消息:
    ws.on('message', function (message) {
        console.log(`[CLIENT] Received: ${message}`);
    }


    a.js export default的引用数据类型a1 
    b.js 引入后赋值给c c改变 a.js的a1也会一起改变
    a1 c 二者还是指向同一地址
    模块化规范
    COMMON.JS
    module.export || exports => require

    ES6
    export.default || export => import from
    ES6的模块化规范在直接node xx.js 无法使用
    需要经过babel转为es5
}

w2: {
  =====d1----05.11=====
  
  禁止遮罩层底部页面滑动
    在遮罩层上 增加 @touchmove.stop.prevent="moveHandle"

    moveHandle() {
      return 
    }

  uniapp 监听页面滚动
  // 页面大小
  this.screenHeight = uni.getSystemInfoSync().screenHeight;
  onPageScroll (e) {
    const { scrollTop } = e
    // 滚动条距离页面顶部的像素
  }

  uni-app动画

  需要动画的视图
  <view :animation="animationData">

  js 
  data: ()=>({
    animationData: {}
  })
  onLoad() {
    // 实例化animation对象
    this.animation = uni.createAnimation()
  }

  methods: {
    // 触发方法
    move() {
      // 调用动画操作方法后要调用 step() 来表示一组动画完成，可以在一组动画中调用任意多个动画方法，一组动画中的所有动画会同时开始，一组动画完成后才会进行下一组动画。step 可以传入一个跟 uni.createAnimation() 一样的配置参数用于指定当前组动画的配置。
      this.animation.height(267).step({duration:200,timingFunction:'ease-in'})
      // 将动画导出 export 方法每次调用后会清掉之前的动画操作
      this.animationData = this.animation.export()
    }
  }


  textarea 被点击获得焦点后，键盘显示后又消失

  对于父元素使用fixed定位的textarea 需要使用fixed = true

  textarea 属于原生组件 层级很高 在外层元素隐藏时 textarea 依旧显示
  可以对textarea进行条件隐藏

  uniapp 使用腾讯视频插件
  在manifest.json 
  "mp-weixin" 内增加
  "plugins": {
    "tencentvideo": {
      "version": "1.3.13",
      "provider": "wxa75efa648b60994b"
    }
  }
  https://mp.weixin.qq.com/wxopen/plugindevdoc?appid=wxa75efa648b60994b&token=&lang=zh_CN
  
  查看最新版本号

  在pages.json 为需要该插件的页面中增加
  "style": {
    "usingComponents": {
    // #ifdef  MP-WEIXIN 
    "txv-video": "plugin://tencentvideo/video"
    // #endif
    }
  }

  在页面中使用
  <txv-video vid="d0965zxxjnu" playerid="txv1"></txv-video>
  vid是是腾讯视频的唯一标识

  
  脑洞
  如果用户修改用户名 
  他的评论显示的用户名也要修改的状况

  评论存储评论用户的id 和用户名
  用户修改名称 对评论的数据表进行筛选 修改该用户的评论信息的用户名

  =====d2----05.12=====



  =====d4----05-15=====
  
  公版
  初始化 没有返回所有数据
  退出小程序 数据会被清空 找不到之前的数据
  修改数据每次只会返回修改的部分
  


  uniapp使用lottie动画

  Lottie，Airbnb开源的一个牛逼的动画框架，绚丽的动画效果令人瞠目。

  Lottie是基于CALayer的动画， 所有的路径预先在AE中计算好， 转换为Json文件， 然后自动转换为Layer的动画。

  Lottie有各种不同的版本， 安卓， iOS， 前端都可以使用， 理论上动画做一套就可以共用， 大大的减少了工作量.以后如果要是实现复杂的动画，可以直接让设计出相关的动画json文件，大大减轻了代码的工作量。

  下载lottie-miniprogram.js

  1. 在插件市场搜索lottie-ui 
  import lottie from '@/common/lottie-miniprogram.js'

  2.npm下载 
  npm i lottie-miniprogram -S

  <canvas id="canvas" type="2d"></canvas>
  import lottie from '@/common/lottie-miniprogram.js'
  export default {
    onReady() {
      uni.createSelectorQuery().select('#canvas').node(res => {
        const canvas = res.node
        const context = canvas.getContext('2d')
        canvas.width = 300//设置宽高，也可以放到wxml中的canvas标签的style中
        canvas.hight = 300
        lottie.setup(canvas)//要执行动画，必须调用setup,传入canvas对象
    
        lottie.loadAnimation({//微信小程序给的接口，调用就完事了，原理不太懂
          loop: true,//是否循环播放（选填）
          autoplay: true,//是否自动播放（选填）
          path:'https://cdn.你的域名.com/aaa.json',//lottie json包的网络链接，可以防止小程序的体积过大，要注意请求域名要添加到小程序的合法域名中
          rendererSettings:{
            context//es6语法：等同于context:context（必填）
          }       
        })
      }).exec()
    }
  }
  path只能为网络路径


  =====d5----05-15=====
  
  模式启动方面
  场景启动

  模式中相同的属性 需要分别使用吗
  
}

w3: {
  =====d1----05-18=====
  
  uniapp 中微信授权登录 以及自动登录
    微信授权登录
    <button open-type="getUserInfo" @getuserinfo="getuserinfo" withCredentials="true">
      微信登录
    </button>

    getuserinfo() {
		uni.login({
			provider: 'weixin',
			success: (res) => {
				let {code} = res
          
				Api.thirdpartLogin({...,code:code}).then(res=>{
					// success
					// data save
					WxAuto.onLogin()
				})
					
			},
			fail() {
				uni.showToast({
					title: '授权失败，请重新点击',
					duration: 2000,
					icon:'none'
				})
			}
		})
    }

    自动登录
    Launch.vue
    if(uni.getStorageSync('code')) {
      WxAuto.checkSession().then(code=>{
        return Api.thirdpartLogin({...,code}) 
      }).then(suc=>{
        // success 
        // data save
      })
    }

    WxAuto.js 
    /**
    * 检查登录态是否过期
    */
    function checkSession() {
        return new Promise((resolve, reject) => {
            uni.checkSession({
                success(res) {
                    //session_key 未过期，并且在本生命周期一直有效
                    let code = uni.getStorageSync('code') || ''
                    resolve(code)
                },
                fail: async (err) => {
                    // session_key 已经失效，需要重新执行登录流程
                    let code = await onLogin()
                    reject(code);
                }
            })
        })
    }

    /**
    * 调用接口获取登录凭证（code）
    */
    function onLogin() {
        return new Promise((resolve, reject) => {
            uni.login({
                provider: 'weixin',
                success: function(res) {
                    if (res.errMsg == "login:ok") {
                        uni.setStorageSync('code', res.code)
                        resolve(res.code)
                    } else {
                        reject(res)
                    }
                },
                fail: function(err) {
                    reject(res)
                }
            })
        })
    }
    module.exports = {
        checkSession,
        onLogin
    }
  
    

    echart在uniapp上的使用
      1. 新建一个项目 通过npm 下载
        npm i echarts mpvue-echarts --save
      2. 将下载的三个库复制到小程序项目的根目录上

      3. 替换最新的 mpvue-echarts 组件中的echarts.vue， 
      源码地址：https://github.com/dcloudio/hello-uniapp/blob/master/components/mpvue-echarts/src/echarts.vue
      替换后查看echarts.vue，可以看到init()通过$emit将onInit事件和数据发出
      
      init() {
        ...
        this.$emit('onInit', {
            width: res.width,
            height: res.height
        });
        ...
      },

      4. 在页面上使用echart
        a.vue
        <template>
          <div class="container">
              <mpvue-echarts ref="pieChart" :echarts="echarts" @onInit="initChart" />
          </div>
      </template>

      <script>
          import * as echarts from 'echarts'
          import mpvueEcharts from 'mpvue-echarts'

          export default {
            data:()=> ({
                echarts,
            }),
            components: {
                mpvueEcharts
            },
            methods: {
              initChart(e) {
                let {
                    canvas,
                    width,
                    height
                } = e
                
                echarts.setCanvasCreator(() => canvas);
                const chart = echarts.init(canvas, null, {
                    width: width,
                    height: height
                })
                canvas.setChart(chart)
        
                var option = {
                    ...
                };
                chart.setOption(option)
                this.$refs.pieChart.setChart(chart)
              }
            }
          }
      </script>

      pro: console不报错，但是页面也不显示图表。
      原因是外框的height为0，需要设置外框的高度。同时要注意page的css
      page{display:flex;}会同样无法显示图表。

    
}

w3: {
	======d3------05.20======
	
	定时器传参
		setInterval(i=> {
			console.log(i)
		},1000,i)
	
	
	watch属性的使用
		1. 使用watch时有一个特点，在数值第一次绑定时，不会执行监听函数，只有值发生改变才会执行。
		如果我们需要在最初绑定值的时候也执行函数，就需要用到immediate属性。
		
		watch: {
		    cityName: {
		    　　handler(newName, oldName) {
		      　　// ...    　　
				},
		    　　immediate: true
		    }
		}
		immediate表示在watch中首次绑定的时候，是否执行handler，
		值为true则表示在watch中声明的时候，就立即执行handler方法，
		值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。
		
		2. 使用 deep 深度监听  （对象里面的属性值发生改变）
		当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听。
		watch: {
		    cityName: {
				handler(newName, oldName) {      // ...    },
				deep: true,
				immediate: true

		}
		设置deep: true 则可以监听到cityName.name的变化，此时会给cityName的所有属性都加上这个监听器，当对象属性较多时，每个属性值的变化都会执行handler。如果只需要监听对象中的一个属性值，则可以做以下优化：使用字符串的形式监听对象属性：
		
		cityName.name': {
		    handler(newName, oldName) { 
		     // ...    
			},
			deep: true,
			immediate: true
		}
		
		这样就只会给对象的某个特定的属性加监听器。
		
		数组（一维、多维）的变化不需要通过深度监听，对象数组中对象的属性变化则需要deep深度监听。
		
}

w4: {
	======d1------05.25======
	
	echart 折线图
	let option = {
	    tooltip: {
	        trigger: 'axis',
	        formatter: function (params) {
				return params[0].name + '时： '+ params[0]value + 'ml' ;
			}
	    },
	    
	    xAxis: {
	        
	        type: 'category',
	        boundaryGap: false,
	        data: [0,1,2,3,4,5,6,7,8,9,110,11,12,13,14,15,16,17,18,19,20,21,22,23]
	    },
	    yAxis: {
	        type: 'value'
	    },
	    dataZoom: [{
	        type: 'inside',
	        startValue:0,
	        endValue: 5,
	        filterMode: 'filter'
	    }],
	    series: [{
	        data: [],
	        type: 'line',
	        smooth: 0.4,
	        color: '#0084ff',
			// 区域颜色
	        areaStyle: {
				// 颜色渐变
	            color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{
	                    offset: 0,
	                    color: '#22a6ff'
	                },
	                {
	                    offset: 1,
	                    color: '#fffffe'
	                }])
	        }
	    }]
	};
	======d2------05.26======
	
	监听授权窗口的点击情况 
	<button open-type="getUserInfo" @getuserinfo="getuserinfo" withCredentials="true"
	
	methods: {
		getuserInfo() {
			uni.getSetting({
				success:(res)=>{
					// 返回值中 authSetting 有一个属性 'scope.userInfo' 
					// 拒绝授权值为 false
					// 允许授权值为 true
					if(res.authSetting['scope.userInfo']) {
						uni.login({
							...
						})
					}
				}
			})
		}
	}
	
	======d3------05.27======
	
	lottie 在uniapp 微信小程序上的展示
		问题1: 真机调试无法显示
		an: 预览显示正常，则发布也可以显示
		
		问题2: path 使用网络文件在开发者平台可以显示，在预览中无法显示
		an: 还未解决 但 lottie.loadAnimation({}) 还有一个属性可以使用本地文件
		animationData: require(本地文件路径)
		使用这个属性，预览就可以显示了
		
	css3 中  tansform 的缩放scale 将元素缩小 但还是占位100%
		解决: 在需要缩小的元素套一个盒子 获取缩小元素的宽高 获得的宽高值就是盒子的宽高
		要给缩小元素设置变换中心为左上角transform-origin: left top;
		
	
	======d4------05.28======	
	wifi绑定修改 
	微信小程序 调用wifi接口
	
		1. 初始化 Wi-Fi 模块 wx.startWifi
			错误码
			12005 Android 特有，未打开 Wi-Fi 开关
			12006 Android 特有，未打开 GPS 定位开关
			   
			wx.startWifi({
				success (res) {
					console.log(res.errMsg)
				}
			})
		   
		   
		2. 连接 Wi-Fi。若已知 Wi-Fi 信息，可以直接利用该接口连接。仅 Android 与 iOS 11 以上版本支持。
			wx.connectWifi
			wx.connectWifi({
				SSID: '',
				password: '',
				success (res) {
					console.log(res.errMsg)
				}
			})
			成功后可以使用 wx.getConnectedWifi 获取已连接中的 Wi-Fi 信息
		   
		
		3. onWifiConnected 监听连接上 Wi-Fi 的事件
		
		getWifiList 请求获取附近的 Wi-Fi 列表
		
		======d5------05.29======
		修改火王微信授权问题
		修改日丰lottie文件显示
		修改日丰样式
}
w5: {
  ======d1------06.01======
  
  用post请求用query+body传参

    1.url里加上query需要传的参数（name:majuan）
    query需要拼接
    
    2.data里放入body要传的参数（tel）


    let tel = 11111  
    dd.httpRequest({
      headers: {
        'Content-Type': "application/json;charset=utf-8",
      },
      url: 'http://192.168.0.0.1:3000/test?name=majuan',//query传的参数name=majuan
      method: 'POST',
      data: JSON.parse(tel),//body传的参数tel
      dataType: 'json',
      success: function(res) {}
    })

  ======d2------06.02======
  
  vue-i18n script 内使用this.$i18n.t('')

  ======d3------06.03======
  
  电影轮播图
  UIScrollView适合图片个数有限的情况，如果是很多或无限个不停加载建议使用UICollectionView实现。

  1.主要实现原理
  根据UIImageView的中心点距离UIScrollView中心的距离进行放大缩小。
  距离中心点UIImageView的size大小时越近则放的比例越大，越远则放大比例越小,最远距离则为size的宽，当超出这个距离则按原尺寸显示。
  原文链接：https://blog.csdn.net/weixin_39339407/java/article/details/102724630
  
  
  ======d4------06.04======
  
  
  微信小程序
  
  应用生命周期

  页面生命周期

  应用生命周期影响页面生命周期

  应用生命周期

  onLaunch (options) {
    // 
    console.log('小程序初始化')

  },
  onShow(options) {
    console.log('监听小程序启动或切前台')
  },
  onHide() {
    console.log('监听小程序切后台')
  },

    1. 用户首次打开小程序，触发 onLaunch（全局只触发一次）。

    2. 小程序初始化完成后，触发onShow方法，监听小程序显示。

    3. 小程序从前台进入后台，触发 onHide方法。

    4. 小程序后台运行一定时间，或系统资源占用过高，会被销毁。

  页面生命周期

    1. 小程序注册完成后，加载页面，触发onLoad方法。

    2. 页面载入后触发onShow方法，显示页面。

    3. 首次显示页面，会触发onReady方法，渲染页面元素和样式，一个页面只会调用一次。

    4. 当小程序后台运行或跳转到其他页面时，触发onHide方法。

    5. 当小程序有后台进入到前台运行或重新进入页面时，触发onShow方法。

    6. 当使用重定向方法wx.redirectTo(OBJECT)或关闭当前页返回上一页wx.navigateBack()，触发onUnload

  应用生命周期影响页面生命周期

    1. 小程序初始化完成后，页面首次加载触发onLoad，只会触发一次。

    2. 当小程序进入到后台，先执行页面onHide方法再执行应用onHide方法。

    3. 当小程序从后台进入到前台，先执行应用onShow方法再执行页面onShow方法。

  Page生命周期
    data                            Object	  页面的初始数据
    onLoad                       Function	生命周期函数--监听页面加载
    onReady	                    Function	生命周期函数--监听页面初次渲染完成
    onShow                      Function	生命周期函数--监听页面显示
    onHide                       Function	生命周期函数--监听页面隐藏
    onUnload                   Function	生命周期函数--监听页面卸载
    onPullDownRefresh	  Function	页面相关事件处理函数--监听用户下拉动作
    onReachBottom	        Function	页面上拉触底事件的处理函数
    onShareAppMessage	Function	用户点击右上角转发
    onPageScroll	            Function	页面滚动触发事件的处理函数
    onTabItemTap	          Function	当前是 tab 页时，点击 tab 时触发
    其他	Any	开发者可以添加任意的函数或数据到 object 参数中，在页面的函数中用 this 可以访问

  component 生命周期
    created: function(){}, // 组件在内存中创建完毕执行

    attached: function(){}, // 组件挂载之前执行

    ready: function() {}, // 组件挂载后执行

    detached: function(){}, // 组件移除执行

    moved: function(){}, // 组件移动的时候执行

    created 组件实例化，但节点树还未导入，因此这时不能用setData

    attached 节点树完成，可以用setData渲染节点，但无法操作节点

    ready(不是onReady) 组件布局完成，这时可以获取节点信息，也可以操作节点

    moved 组件实例被移动到节点树的另一个位置

    detached 组件实例从节点树中移除


  ======d5------06.06======
  
  vue生命周期
  vue
  开始创建vue实例 （时间点）
  ↓↓↓
  初始化事件和生命周期函数（时间段）
  —— 当其结束的时候代表beforeCreate生命周期函数的调用，此时虽然数据已经准备完成，但是并没有注入到vue实例中，所以beforeCreate不能获取到data，当然视图层的渲染要更晚。
  beforeCreate生命周期函数中没有data和el
  ↓↓↓
  开始注入函数和数据（时间段）
  ——当前结束的时候，数据注入完成。所以created生命周期函数能够获取到data，但是没有挂载数据到view层
  created生命周期函数中有data，没有el
  ↓↓↓
  这个时候就会检测是否存在el的参数，没有就会等待el参数的传递
  （不传递就不再进行下一步）
  有就会继续检测是否存在template的参数
  （在vue实例中如果存在template，就在render函数中使用这个template，没有就使用要挂载的节点的html作为template）
  比如，vue实例对象中有：template: "<h1>{{message +'这是在template中的'}}</h1>"就不会使用html部分el内部的html。
  ------当前结束时就代表beforeMount的调用，因为必须给定el，实例方法才会继续下去，所以le此时是能够获取到
  beforeMount生命周期函数中有data，有el
  ↓↓↓
  挂载数据到view层（时间段）
  之前可以看出仅仅只是找到这个el参数，并没有对视图层做处理。现在要做的就是挂载数据到view上，创建vue实例下的el，挂载到view上。这个时候vue中的数据就会渲染到html中
  ------ html中所有的数据完成，代表mounted的调用
  ↓↓↓ （分支）
  当数据改变时，触发beforeUpdata和updata
  ↓↓↓（分支）
  销毁实例（时间段）
  首先是beforeDestory
  销毁完成的时候
  destoryded


  ======d6------06.06======
  
  uni canvas层级最高 其他元素无法覆盖canvas
    解决方法 
    使用canvas作为盒子 内部使用cover-view或cover-image
    cover-view/cover-image内部只能嵌套cover-view cover-image
    cover-view是文字
}
w6: {
  ======d1------06.08======
  
  uni 返回上一个页面带参数
    let pages = getCurrentPages();  //获取所有页面栈实例列表
    let nowPage = pages[ pages.length - 1];  //当前页页面实例
    let prevPage = pages[ pages.length - 2 ];  //上一页页面实例
    prevPage.$vm.flag = i;      //  这是上个页面data中flag的值 
    this.$Page.navigateBack()
}
w9: {
	======d1------06.29======
	微信小程序保持屏幕常亮
	原生小程序 在App.js的onShow函数中写
	wx.setKeepScreenOn{{
		keepScreenOn: true
	}}
	IOS兼容 IOS需要在需要屏幕常亮的页面的onShow写上setKeepScreenOn
	
	小程序的api保持屏幕常亮作用在整个小程序，但是在当前页面设置常亮后，跳转页面，安卓手机保持长亮，但苹果手机却无法保持长亮。
	
	注意：
	
	后发现在苹果手机中wx.setKeepScreenOn的设置只对当前页有效，所以我们如果需要在整个小程序中或者在操作中保持屏幕常亮，则需要在每个页面设置，或者你可以在app.js中设置。
	
	ps： 在uniapp中在App.vue 写
	wx.setKeepScreenOn{{
		keepScreenOn: true
	}}
	安卓手机保持长亮，但苹果手机却无法保持长亮
	
	uniapp 只要在App.vue的onShow函数中写上
	uni.setKeepScreenOn({
		keepScreenOn: true
	})
	
	使用后台的token验证登录状态  登录可以获取用户信息和token
	理论上只保存token 再次打开通过验证token的有效性 来确认登录状态
	验证通过后台验证 前端请求一些需要token权限的接口 后端检查后会返回特定的失效信息码
	用户信息是通过登录获取的 因此只能在登录成功后把用户信息存起来
	关闭应用时再次存储用户信息 打开应用时使用存储中的用户信息
	但是 用户可能在另一台设备登录后 修改了用户信息 这就会造成用户信息不一致
	
	======d4------07.02======
	
	微信小程序 swiper-item 嵌套 scroll-view 
	swiper-item 到 scroll-view 都要给高度
	
	uniapp 小程序上
	canvas 绘制图片到画布
		canvasContext.drawImage(src,dx, dy, dWidth, dHeight)
		src	String	所要绘制的图片资源
		dx	Number	图像的左上角在目标canvas上 X 轴的位置
		dy	Number	图像的左上角在目标canvas上 Y 轴的位置
		dWidth	Number	在目标画布上绘制图像的宽度，允许对绘制的图像进行缩放
		dHeight	Number	在目标画布上绘制图像的高度，允许对绘制的图像进行缩放
	
	
	canvas查看某个区域的像素
	
		uni.canvasGetImageData(OBJECT,this)
		返回一个数组，用来描述 canvas 区域隐含的像素数据，在自定义组件下，第二个参数传入自定义组件实例 this，以操作组件内 <canvas> 组件
		
		OBJECT 返回的参数
		canvasId	String	是	画布标识，传入 <canvas /> 的 canvas-id
		x	Number	是	将要被提取的图像数据矩形区域的左上角 x 坐标
		y	Number	是	将要被提取的图像数据矩形区域的左上角 y 坐标
		width	Number	是	将要被提取的图像数据矩形区域的宽度
		height	Number	是	将要被提取的图像数据矩形区域的高度
		success	Function	否	接口调用成功的回调函数
		fail	Function	否	接口调用失败的回调函数
		complete	Function	否	接口调用结束的回调函数（调用成功、失败都会执行）
		success回调返回参数：
		
		errMsg	String	
		width	Number	图像数据矩形的宽度
		height	Number	图像数据矩形的高度
		data	Uint8ClampedArray	图像像素点数据，一维数组，每四项表示一个像素点的rgba
		
		实例
		uni.canvasGetImageData({
		  canvasId: 'myCanvas',
		  x: 0,
		  y: 0,
		  width: 100,
		  height: 100,
		  success(res) {
		    console.log(res.width) // 100
		    console.log(res.height) // 100
		    console.log(res.data instanceof Uint8ClampedArray) // true
		    console.log(res.data.length) // 100 * 100 * 4
		  }
		})
	
	vue的节流 
	
	小程序上使用svg 
		
		svg文件 <svg ....>.....</svg>
		先将文件进行压缩 (也可以不压缩)
		
		把svg格式先转为data类型的url 下面为转换网站
		https://codepen.io/jakob-e/pen/doMoML
		这一步本质上是先对svg做了url-encode，主要是#</>这些符号做转义。然后在转义后的字符串前面加上data:image/svg+xml,字样。
		
		我们将该svg文件保存在一个js中
		通过background-image调用
		
		
	小程序上的svg修改颜色
		先替换svg文件中所有的十六进制颜色为主题色，然后再填充到background-image的url中即可
	
	======d5------07.03======
	
	es6 将对象的一部分属性合并到另一个对象上
		var obj = {
		    a: 1,
		    b: 2,
		    c: 3,
		    d: 4,
		    e: 5
		}
		var {a, d, e} = obj
		var obj2 = {a, d, e}    
		
		
	canvas性能优化
	小程序的WXS性能响应事件
}

w10: {
	==d1---07.06==
	
	new RegExp()
	\需要转义
	\d需要\\d
	
	
	==d4---07.09==
	
	函数内改变数组参数 会使 数组发生改变
	
	
	 
}
w11: {
	==d1---07.13==
	
	js中的十进制和十六进制转换
		
		十转十六
		Number.toString(16)
		
		十六转十
		parseInt(item,16)
	
	小程序使用setTimeout 在离开当前页面时依然会继续 
		需要在unload进行清除定时器的操作
	
	
	场景 操作需要在某个时间段后才能操作
		比如 点击按钮 60秒后才能在点击
		可以利用时间戳
		保存点击触发的时间戳 在每次点击操作是获取点击的时间戳
		与上一次触发的时间戳进行比较 
		大于时间段60s 则触发 并将当前的时间戳赋值 
	
	
	=d3--0715===
	
	正则捕获组
	var reg = /([a-z]+)(\d+)/;					//匹配一个或多个字母，和一个或多个数字
	reg.test('hello123');						//ture
	console.log(RegExp.$1)						//输出 hello，即匹配的第一个括号里的内容
	console.log(RegExp.$2)						//输出 123  ，即匹配的第二个括号里的内容
	
	
	
	var reg = /([a-z]+)(\d+)/;
	var str = 'hello123';

	var result = str.replace(reg,'$2,$1')				
	
	console.log(result)					//结果为   123,hello
	
	let reg = new RegExp('([a-z]+)(\d+)', 'g')
	let res = str.replace(reg, '1')
	RegExp.$1  	// hello
	
}
w12: {
	=d1--0720=
	
	小程序监听物理返回键或返回手势
	以及导航栏上的返回键
	
		小程序不支持这个API 
		可以在onUnload钩子函数上监听页面卸载
	
		uniapp在h5,APP有一个onBackPress(event)钩子函数
		返回 event ={from: backbutton | navigateBack}
		Android 实体返回键 (from = backbutton)
		顶部导航栏左边的返回按钮 (from = backbutton)
		返回 API，即 uni.navigateBack() (from = navigateBack)
	
	vue获取焦点
		<input ref="ipt" />
		script 
		this.$refs.ipt.focus()
	
		@focus input框获取焦点时触发
		@blur 监听input框失去焦点时触发
	
	vuex 
	获取不同模块中的值
	module:{
		a: moduleA
	}
	
	vue script 
	import {mapState} from 'vuex'
	computed: {
		...mapState({num: state=>{return state.a.num}})
	}
	
	
	律动和场景如果不在该页面 就无法传值了

  =d2--0721==
  小程序 引用文件
    小程序有两种引入js文件的方式
    require 和 import 
    但是只能使用相对路径
    可以在app.js上定义方法
    require(url){
      return require(url)
    }
    在需要的组件上 如index.js
    const app = getApp()
    const utils = app.require('utils/utils')

    小程序 父子组件传递
    
    小程序 自定义无法使用app.wxss 可以通过@import '/app.wxss' 引入后使用

    =d3--0722=

    vue获取data数据能获取对象，但打印里面的值为空？
      可能是对象在异步函数中赋值 打印的时候没有值 
      在异步函数完成后 chrome会再次刷新该对象 
      此时控制台可以看到对象 但是打印对象的值就会显示为空

    微信小程序 如何在{{}}中使用函数？WXML+WXS

      小程序里无法直接使用js的函数 如 item.slice(0)

      需要使用到wxs
      WXS(WeiXin Script) ,小程序的一套脚本语言，可以在WXML的{{}}中调用.wxs的方法。
      
      新建一个wxs文件
      var filter = {
        numberToFixed: function(value){
          return value.toFixed(2)
        }
      }
      // 导出对外暴露的属性
      module.exports = {
        numberToFixed: filter.numberToFixed
      }

      在wxml中引入
      <!-- 引入.wxs文件 src为相对路径，module指定当前模块的名称 -->
      <wxs module="filter" src="./numberToFixed.wxs"></wxs>

      在{{}}中调用方法
      <view>￥{{filter.numberToFixed(cashMoney*0.02)}}手续费(费率2%)</view>
	  
	  connectWifi({
	    SSID: '',
	    password: '',
	    success (res) {
	      console.log(res.errMsg)
	    }
	  })
	  success 表示接口调用成功 并不是连接成功
	  可以使用getConnectedWifi  查看连接的wifi名是否一致
	  getConnectedWifi: 获取已连接中的 Wi-Fi 信息。
	 
	  wx.getConnectedWifi({
	  	success: res => {
	  		that.curWifi = res.SSID
	  		console.log(res)
	  		if(res.wifi.SSID.startsWith("adh_")){
	  			clearInterval(this.getWifiInterval)
	  			PageUtils.navTo(PageUtils.ADD_DEVICE_CONFIGING,this.wifiInfo)
	  		}
	  	}
    });
    
  =d4--0723==

  微信小程序 wxs 的函数不能用es6的写法
  fun(){
    return a
  }

  js使用data，prop的数据
    data: {
      a: '11'
    },
    properties: {
      b: ''
    }
    this.data.a
    this.properties.b
  
  wxml向js传递参数
    使用dataset自定义属性
    <view bind:tap="onTap" data-id="3"></view>

    onTap(e) {
      console.log(e.target.dataset.id)
    }
  
  wxml 动态class 
    <view class="w-all {{fontClass}}"></view>
    <view class="w-all f-{{index}}"></view>
}
w13: {
  =d1--0727=

  如果第二行是 ([+-/ 开头
  那么第一行末尾需要加分号 不然会编译时会当成一行
  比如 
    yield a
    [a,b] = [b,a+b]
    会当成 yield a[a,b] = [b,a+b] 最后 yield [a,a+b]

    一、自动插入分号规则
    1.1、三条规则
    要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。
    有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。
    源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。

    IIFE 立即执行函数
    (function(){
      console.log(1);
    })()      // 这里没有分号
    (function(){
        console.log(2);
    })()

    // 不加分号，输出结果 输出1后报错
    // 1   Uncaught TypeError: (intermediate value)(...) is not a function

    no LineTerminator here 规则
      表示它所在的结构中的这一位置不能插入换行符。所以要加分号 再换行
      
      1.带标签的 continue 语句
      2.return
      3.后自增、后自减运算符
        i/**/++
      4. throw 和 Exception 之间
      5. async 关键字
      6. 箭头函数
        // 箭头函数的箭头前，也不能插入换行
        const f = x/*no LineTerminator here*/=> x*x
      7. yield
        // yield 之后，不能插入换行
        function *g(){
            var i = 0;
            while(true)
                yield/*no LineTerminator here*/i++;
        }

      不写分号需要注意的情况
      如果第二行是以 ([+-/   Template 开头的语句
        那么第一行末尾需要加分号 不然会编译时会当成一行
  
  iterator(迭代器) generator(生成器)

  generator 返回的迭代器对象 {value:yield的值,done:当没有更多可返回数据时返回true,否则返回true}
      
}
w: {
  =d4--0806=
  小程序分享功能
  第一种 右上角分享
  第二种 使用button
    <button open-type="share">
    点击button后会触发 onShareAppMessage 钩子函数
    onShareAppMessage() {
      return {
       title: '标题',
       desc: '分享页面的内容',
       path: '' // 路径，传递参数到指定页面。
      }
    }

  小程序使用lottie 在页面重载lottie动画不执行问题
    描述: 如果第二次进入页面 Lottie动画不执行
    原因: 第一次页面销毁时动画不会结束，也就是lottie不能自动销毁requestAnimationFrame回调里的动画

    let frameFn = function () { };
    let rid = 0;
    let canvasDom = null;
    page({
      onReady () {
          wx.createSelectorQuery().select('#canvas').node((res) => {
            const canvas = res[0].node;
            canvas.width = 240
            canvas.height = 240
            const requestAnimationFrame = canvas.requestAnimationFrame;
            canvas.requestAnimationFrame = function () {
              frameFn = arguments[0];
              rid = requestAnimationFrame.apply(canvas, arguments);
              return rid;
            }
            // 页面第二次打开时动画默认不会开始，这里需要手动调用一次动画
            canvas.requestAnimationFrame(frameFn);
            canvasDom = canvas;
            lottie.setup(canvas);
            lottie.loadAnimation({
              autoplay: true,
              loop: true,
              animationData: require('./ani.js'),
              rendererSettings: {
                context: canvas._ctx
              }
            });
          }).exec();
        },
      onUnload () {
        // 销毁页面时 关闭动画
        canvasDom.cancelAnimationFrame(rid);
      }
      ps: uni小程序也可以使用
	  
	})

}
w: {
	=d4--0813=
	微信小程序获取手机号
	wx.login({
		
	})
	获取code appid 发送给服务器 服务器向微信服务器换取 openId session_key
	
	<button class="text-center reset-btn" open-type="getPhoneNumber" @getphonenumber="getphonenumber">
	 
	getphonenumber(e) {
		console.log(e)
		let {errMsg, iv, encryptedData} = e.detail
	}
	将iv, encryptedData发给服务器 服务器使用session_key进行解密
}
W: {
	=d4--0820=
	
	js使用vuex
	.js
	引入store 
	import store from '@/store'
	
	store.dispatch('action type',value)
	
	=d5--0821= 
	flex自适应宽度显示省略号
	给需要出现省略号的元素
	flex: 1;
	width: 0;（或者一个较小的宽度）
	单行省略
	text-overflow:ellipsis;
	overflow:hidden;
	white-space: nowrap;
}
w: {
	=d1--0824=
	解决小程序lottie出现锯齿的情况
		将canvas的寛高放大 再用css的scale缩小到需要的大小
}
w: {
  =d2--0901=
  echarts 引入json地图文件
  vue版本:
  import echarts from 'echarts'
  // 引入json文件
  import JSON from './jiaxing.json' 
  var myChart = echarts.init(this.$refs.echart_box) // 拿到一个实例
  echarts.registerMap('嘉兴市', JSON, {})//引入地图文件
  let option = myChart.getOption();
  option.geo[0].map = '嘉兴市';
  // 或者 
  var option = {
    series: [
      {
        type: 'map',
        mapType: '嘉兴市'// 地图名称
      }]
  }

  myChart.setOption(option, true);

  中国，省份，城市地图下载
  http://datav.aliyun.com/tools/atlas

 
  小程序 input框获取焦点后 字体变粗
  解决 给input样式 
  font-weight: normal

  伪类
    按住 正常->active 抬起 active->正常 
    ex:如果只想active->正常有动画 就在正常添加过渡 设置active的过渡为0s 没有动画
	=d4--0903=
	uni的坑 
	uni小程序运行到手机上
	注意
	1. 不要直接在组件上绑定事件 小程序可以触发 app端不能触发
	通过 this.$emit 触发自定义函数
	2. 组件要和components的名字一样 不要用-拼接
	3. app端对echarts支持度不高
		可以使用renderjs
		renderjs是一个运行在视图层的js。它比WXS更加强大。它只支持app-vue和h5。
		
		renderjs的主要作用有2个：
		
		大幅降低逻辑层和视图层的通讯损耗，提供高性能视图交互能力
		在视图层操作dom，运行for web的js库
	现在还没试出来
	
	4. uni.createSelectorQuery()在app端无效？？
	
	zoom: .5
	也可以实现缩放 
	
	SelectorQuery() 在app端需要放在this.$nextTick(()=>{})中
}
w: {
  =d1--09.14=
  vuecli3 使用.env文件配置全局环境变量

  在根目录下新建.env.dev .env.pro文件
  .env.dev是开发环境下的文件
  .env.production是生产环境下的文件

  .env.dev内容
  NODE_ENV= development 
  VUE_APP_ENV=dev
  VUE_APP_BASE_URL = 'http://localhost'
  VUE_APP_PORT = '8081'
  
  一定要以VUE_APP_开头

  package.json的"script"
    增加: "dev": "vue-cli-service serve --mode dev"
  
    运行时输入npm run dev

    在vue中打印process.env

  axios自定义
  axios.create({
    baseURL: '',
    header: {},
    timeout: number
  })
  

  =d2--0915=
  vuecli3.0 + ts +vuex
    下载 vue-module-decorators
    
    动态模块
    // @/store/module/user.ts

    // 动态模块
    import { Module, VuexModule, Mutation, Action, getModule } from 'vuex-module-decorators'
    import store from '@/store'

    interface Account {
      id: string|number,
      name: string
    }
    // dynamic: true: 动态创建动态模块,即new Vuex.Store({})里面不用注册的.空着就行,
    // store,当前模块注册到store上.也可以写在getModule上,即getModule(PassengerStore,store)
    // namespaced: true, name: 'passenger' 命名空间
    @Module({
      name: 'user',
      dynamic: true,
      namespaced: true,
      store
    })
    export default class UserStore extends VuexModule {
      public account: Account = {
        id: '',
        name: ''
      }

      // getter
      get getAccount(): string|number {
        return this.account.id
      }

      @Mutation
      SET_USER(obj: Account) {
        console.log(obj)
        this.account = obj
      }

      @Action 
      setUse1(): void {
        let obj: Account = {id: '1',name:'aa'}
        this.context.commit('SET_USER',obj)
      }
      @Action({commit: 'SET_USER'})
      setUser2(): Account {
        return {id: 2, name: 'cc'}
      }
    }

    export const UserStoreModule = getModule(UserStore)


    // @/store/index.ts
    import Vue from 'vue'
    import Vuex from 'vuex'
    import user from './module/user'

    Vue.use(Vuex)

    export default new Vuex.Store({})

    // index.vue

    import {Component, Vue, Watch} from 'vue-property-decorator'
    import { UserStoreModule} from '@/store/module/user'
    
    @Component
    export default class Index extends Vue {
      mounted() {
        UserStoreModule.setUser2()
        console.log(UserStoreModule.account)
      }
    }
  
    

  =d5--0918==
  vue-cli3 引入typescript
  怎么说呢 很麻烦
    1. 下载
    npm install ts-loader typescript --save-dev
    npm install vue-property-decorator --save-dev
    npm install vuex-class

    2.增加tsjson.json

    {
      "compilerOptions": {
        "target": "es5",
        "module": "commonjs",
        "strict": true,
        "strictNullChecks": true,
        "esModuleInterop": true,
        "experimentalDecorators": true
      }
    }
    # 应该不止

    3.增加代码到vue.config.js
    configureWebpack: {
      resolve: { extensions: [".ts", ".tsx", ".js", ".json"] },
      module: {
        rules: [
          {
            test: /\.tsx?$/,
            loader: 'ts-loader',
            exclude: /node_modules/,
            options: {
              appendTsSuffixTo: [/\.vue$/],
            }
          }
        ]
      }
    }

    4.修改main.js 为main.ts

    5.增加shims-vue.d.ts shims-jsx.d.ts jsx文件这个我不觉得是必须的
    在引入.vue文件时要补全后缀 ts无法识别vue 需要显式书写
    
    shims-vue.d.ts
    
    declare module "*.vue" {
      import Vue from "vue";
      export default Vue;
    }

    6.将.vue文件改造


  解构赋值

  对象的解构赋值是下面的简写
  let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };

  let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
  baz // "aaa"

  let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
  baz // "aaa"
  foo // error: foo is not defined

  var {x: y = 3} = {};
  y // 3

  var {x: y = 3} = {x: 5};
  y // 5

  默认值生效的条件是，对象的属性值严格等于undefined

  函数解构赋值使用默认值

  function move({x = 0, y = 0} = {}) {
    return [x, y];
  }
  
  move({x: 3, y: 8}); // [3, 8]
  move({x: 3}); // [3, 0]
  move({}); // [0, 0]
  move(); // [0, 0]

  上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。

  function move({x, y} = { x: 0, y: 0 }) {
    return [x, y];
  }
  
  move({x: 3, y: 8}); // [3, 8]
  move({x: 3}); // [3, undefined]
  move({}); // [undefined, undefined]
  move(); // [0, 0]
  
  上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。

  undefined就会触发函数参数的默认值。
}
w: {
  =d1--0921==
  聊天室 昵称 聊天记录不保存
  单对单 账号密码 保存
  搜索用户

  模仿乐乎 还是做图片展示 需要api 知乎日报api 内容太少
  n个导航 
    分享图片 文字 把发布移到这个导航下 
    展示知乎日报
  
  重构这个app的难度 没有什么扩展的内容 不知道接入什么api

  做一个什么好呢 使用api 还是用数据库 数据库是一定会有的 但是还是要有一些API内容

  我可以把这个app简化成一个博客交流的 不对 
  
  爬虫 存入数据库 或者将数据存在一个本地json中 最好是动态的

  看一下hooks mixins

  
  ts在使用组件内导航守卫时需要进行注册

  import {Vue,Component} from 'vue-property-decorator'

  Component.registerHooks([
    'beforeRouteLeave'
  ])
  export default class Tem extends Vue {
    beforeRouteLeave(to: any, from: any, next: any) {
      if(flag) {
        next()
      } else {
        next(false)
      }
    }
  }

  beforeRouteLeave 可以用在离开该组件所在的路由时需要提示保存时使用
}

w: {
  =d2-0929=
  arr.reduce((prev,cur,index,arr)=>{

  },init)
  prev 表示上一次回调返回的值 或者是初始值
  cur 表示当前的数组元素
  index 正在处理的数组元素索引 有init值 索引为0 否则为1
  init 表示初始值

  数组求和 
  arr.reduce((prev,cur)=>{
    return prev + cur
  },0)

  reduce() 是数组的归并方法，与forEach()、map()、filter()等迭代方法一样都会对数组每一项进行遍历，但是reduce() 可同时将前面数组项遍历产生的结果与当前遍历项进行运算，这一点是其他迭代方法无法企及的
}

w: {
  ==d6--1010=
  rifeng多语言完成页面
  pageA me cyclopedia scenes
  add_device 到wifi_config
}

w: {
  =d1--1012=
  e.currentTarget.offsetTop

  touches = e.changedTouches[0]
  touches.clientX
  touches.pageY
  touches.x 
  touches.y
  明天要做的 公版 红酒柜数据点修改, 设备列表样式修改

  =d2--1013=
  rifeng多语言完成页面
  pageA:  
    me cyclopedia scenes add_device 
    deviceconfig 准备1 2完成了
  
    page: 
     cycl me scene user useinfo没改

     device.common:
      DM没改
      
  =d3--1016=
  uniapp 不支持 props 传递对象里的属性有函数
}
w: {
  =d1--1019=
  q: svg在小程序中会出现大小不符 错位
  a: svg使用的是px 小程序使用的是rpx 所以在iphone6以外的比例 可能有错误
     需要将尺寸转化为相应的px值

     let scale = wx.getSystemInfoSync().screenWidth / 750
     let width = 'svg原本的宽度' 
     width = width*2*scale
  
  =d2-1020=
  i18n 
  对复数不同的
  $tc()

  =d3-1021=
  q: 瀑布流需要计算高度的类型 图片还没有获取完就已经渲染上去, 造成视图显示不完整
  
  a: 获取数据后，遍历数据数组，预加载图片，计算图片缩放后的高度，存储起来。
    同时由于图片加载是异步加载，所以用变量计数，当最后一个图片加载完成后，开始渲染页面。
    
    loadImagesHeight(list){
      var count = 0; //用来计数，表示是否所有图片高度已经获取
      list.forEach((item, index)=>{
       //创建图片对象，加载图片，计算图片高度
       var img = new Image();
       img.src = item.cover;
       img.onload = img.onerror = (e)=>{
       count++;
       if (e.type == 'load'){ //图片加载成功
        //计算图片缩放后的高度：图片原高度/原宽度 = 缩放后高度/缩放后宽度
        list[index].imgHeight = Math.round(img.height * this.boxWidth / img.width);
        // console.log('index: ', index, ', load suc, imgHeiht: ', list[index].imgHeight);
       }
       else{ //图片加载失败，给一个默认高度50
        list[index].imgHeight = 50;
        console.log("index： ", index, "， 加载报错：", e);
       }
     
       //加载完成最后一个图片高度，开始下一步数据处理
       if (count == list.length){
        this.resolveDataList(list);
       }
       }
      })
    }

    对于组件可以组件mounted中
    mounted: {
      let self = this
      this.$nextTick(()=>{
        let img = new Image()
        img.src = self.item.url[0]
        img.onload = function() {

          // 计算高度
        }
      })
    }
  =d5--1023=
  t: 联系设备端设计数据点 考虑设备端上报的情况

  =d3--1028=
  q: 使用sourceTree进行代码推送 或直接用git推送时弹出窗口提示输入github账号密码 输入后错误
  a: 窗口的密码不是账号密码 而是token 点击github头像->setting

  =d4--1029= 
  t: antd + vue 多语言
  需要修改 业务语言+ 日期格式 + 组件内语言
  使用库 vue-i18n moment 
  使用antd组件 <a-locale-provider :locale="locale"></a-locale-provider>
  
  在main.js定义i18n
  并定义一个全局切换方法
  main.js 
  new Vue({
    ...
    data: {
      return　{
        Bus: new Vue()
        // 定义一个空的Vue实例 所有的组件都能使用
      }
    }
  })

  在App.vue
  将router-view用国际化组件包裹起来
  <a-locale-provider :locale="locale">
    <div id="app">
      <router-view v-if="isRouteActive" />
    </div>
  </a-locale-provider>

  ps: 在高版本中 a-locale-provider 已被废弃 现在使用a-config-provider

  js
  import zh_CN from 'ant-design-vue/lib/locale-provider/zh_CN'
  import en from 'ant-design-vue/lib/locale-provider/en_US'
  import moment from 'moment'
  import 'moment/locale/zh-cn'

  moment.locale('zh-cn')
  export default {
    name: 'App',
    data () {
      return {
        locale: zh_CN,
        isRouteActive: true
      }
    },
    created() {
      // 初始化localStorage的语言
      ...
      this.$root.Bus.$on('switchLang',()=>{
        // 切换 moment 
        // 切换i18n
        // 切换data的locale
        ...
      })
    }
  }

  =d5--1030=

  q: uni的switch 在checked值没有发生变化时 改变状态
    例如在点击switch 请求接口 接口调用失败 checked没有改变
    但此时switch的状态已经发生改变
  a: switch的cheecked不是双向绑定
    用一个view作为点击 在接口返回后,根据返回状态修改checked
    <view class="p-r">
			<switch :checked="!!switchData.enable" />
			<view class="box-all p-a" style="left: 0;top: 0;" @tap="onChange"></view>
    </view>
    
  q: vue项目运行时内存溢出
  a: 打开一个cmd窗口 
    执行 setx NODE_OPTIONS --max_old_space_size=4069（如何不行的许，可以再设置大点）
    关闭所有cmd /代码编辑器
    重新打开cmd并再次运行节点命令（npm等）
}
w: {
  =d4--1105=
  q: uni.hideLoading()后使用uni.showToast() 真机上提示音没有按设置的时长显示 显示很短时间
  a: hideLoading也可以隐藏showToast 可以再hideLoading执行完成后再调用showToast 比如使用setTImeout
}
w: {
  =d4--1112= 
  uni.$emit() uni.$on() uni.$off()
  通过$emit触发 在$on监听事件
  tip: 如果在不同页面有不同的操作 记得在页面卸载或隐藏时要解绑事件
  如果都是相同的操作 可以再app.vue里写
  
  css变量
  :root {
    --color: #222;
  }
  .app {
    background: var(--color)
  }

  tip: 变量以--开头 使用时要用var()包起来

  =d5--1113=
  q: uniapp 小程序使用lottie-miniprogram.js 动画可见但是没有执行
  a: 删除lottie-miniprogram这2行代码就好

    window.requestAnimationFrame = canvas.requestAnimationFrame.bind(canvas)

    window.cancelAnimationFrame = canvas.cancelAnimationFrame.bind(canvas)

    dist文件是

    e.requestAnimationFrame=t.requestAnimationFrame.bind(t),e.cancelAnimationFrame=t.cancelAnimationFrame.bind(t),
  
  uniapp picker-view的样式

  picker-view自身的style在最底层
  mask-style mask-class 在倒数第二层
  
}